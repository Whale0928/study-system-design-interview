# 12장 - 실시간 채팅 시스템

---

## 1. 채팅 시스템 설계범위 확정

- 1:1채팅과 그룹채팅 (latency 고려필요)
- DAU(Daily Active User: 일별 능동 사용자 수) 규모
- 필수적으로 요구되는 기능 (채팅, 사용자 접속상태, 텍스트, 이미지 여부 등)
- 주요 서비스: 페이스북 메신저, 구글 행아웃, 디스코드, 라인

<br/>

## 2. 통신 프로토콜 탐색과 개략적 설계

### 2-1. 폴링 (polling)
<img width="429" alt="스크린샷 2024-01-01 오후 6 21 19" src="https://github.com/organization-for-study/study-system-design-interview/assets/126097518/8eef354a-ae71-4d0f-8da9-162dfec91f46">

- 클라이언트가 주기적으로 서버에게 새 메시지가 있는지 확인하는 방식.
- 폴링비용은 폴링이 잦을수록 증가.
- 불필요한 트래픽 및 부하. → 메시지가 없는 경우에도 주기적으로 확인.
  
<br/>

### 2-2. 롱 폴링 (long polling)
<img width="451" alt="스크린샷 2024-01-02 오후 11 25 59" src="https://github.com/organization-for-study/study-system-design-interview/assets/126097518/bcf513f2-3665-48cd-8ae3-fce5718fe33d">

- 클라이언트가 주기적으로 서버에 요청을 보내고, 서버는 새로운 정보가 생기면 응답을 보내는 방식.
    
    ⇒ 불필요한 트래픽 감소. (폴링방식의 단점 보완)
    
- 송수신 클라이언트 간의 롱 폴링 연결 불일치 서버 가능성 발생. (라운드로빈 알고리즘 사용.)
- 여전히 자원낭비 발생 및 비효율적 (메시지가 없는 경우에도 클라이언트는 주기적으로 서버에 접속)

<br/>

### 2-3. 웹소켓 (WebSoket) ✅

<img width="461" alt="스크린샷 2024-01-02 오후 11 46 38" src="https://github.com/organization-for-study/study-system-design-interview/assets/126097518/e0157841-588e-45a8-86ed-6d7a6f5dea7c">


- 양방향 비동기 통신을 지원하는 통신 프로토콜. → 실시간 데이터 송수신 가능.
- 한번 맺어진 연결은 항구적임. (HTTP 핸드셰이크 → 웹소켓 프로토콜 연결)
- 폴링의 단점 보완.
    - 양방향 통신. → 클라이언트와 서버는 동시에 데이터를 주고받음.
    - 폴링 방식 보다 낮은 latency. → 서버 푸시 기능 등.
    - 서버 부하 감소. (반복적인 HTTP 연결 < 연결유지)
    - 작은 헤더 오버헤드 → 데이터 전송 시 큰 오버헤드 발생 X.
      
<br/>

### 2-4. 웹소켓을 이용한 채팅 앱 개략적 설계

**무상태 서비스**

<img width="455" alt="스크린샷 2024-01-03 오후 10 53 39" src="https://github.com/organization-for-study/study-system-design-interview/assets/126097518/c7730099-6560-45d3-b865-75e05a8b1c9e">


- 무상태 서비스는 각각의 클라이언트 요청을 독립적으로 처리 & 서버는 클라이언트의 상태를 기억하지 않음. → 서버를 수평적으로 확장하기 쉬움 (동기화문제 최소화)
- 빠른 응답시간과 간편한 관리 및 유지보수
- 무상태 서비스를 로드밸런스 뒤에 위치시켜 관리 → 서버를 여러 대 두고 로드 밸런서를 통해 트래픽을 분산시키면 전체 시스템의 확장성이 향상됨.
- 실시간 서비스에 적합한 아키텍처
  
<br/>

**상태 유지 서비스**

- 각 클라이언트가 채팅 서버와 독립적인 네트워크 연결을 유지해야 함.
  
<br/>

**제3자 서비스 연동**

- 푸시 알림 제 3자 서비스 연동 필요
  
<br/>

**개략적인 설계안**

<img width="506" alt="스크린샷 2024-01-03 오후 11 23 10" src="https://github.com/organization-for-study/study-system-design-interview/assets/126097518/c9b9f98a-cf3b-4158-a749-c77b94e15258">

<br/>

**저장소**

- 사용자 프로파일, 설정, 친구 목록과 같은 일반 데이터 ⇒ RDBMS
- 채팅이력(chat history) ⇒ 키-값 저장소 (key-value)
<br/>

**데이터모델**

- 메시지ID (참고: [7장 분산시스템을 위한 유일 ID 생성기 설계](https://github.com/organization-for-study/study-system-design-interview/blob/main/chapter7/DistributedSystemUniqueIdDesign.md))
    - RDBMS - auto_increment
    - 스노플레이크 - 64-bit 순서 생성기
    - 지역적 순서 번호 생성기
 
<br/>
<br/>

## 3. 상세설계와 디스코드

**서비스 탐색**
- 클라이언트의 위치 및 서버의 용량 고려.
- 아파치 주키퍼 오픈 소스 솔루션 (분산환경에서의 조율 및 동기화 분산 서비스 프레임워크)
- 서비스 탐색 기능을 통해 해당 사용자를 서비스할 최적의 채팅 서버 탐색 후 웹소켓 연결.

  
<br/>

**메시지 흐름**

- 1:1 채팅 메시지 처리 흐름
  
  <img width="458" alt="스크린샷 2024-01-03 오후 11 45 32" src="https://github.com/organization-for-study/study-system-design-interview/assets/126097518/d409eb81-6bf9-4d82-8a94-a80b7f9bc018">

1. 사용자 A가 채팅 서버 1로 메시지 전송
2. 채팅 서버 1은 ID 생성기를 통해 해당 메시지 ID 결정.
3. 채팅 서버 1은 해당 메시지를 메시지 동기화 큐로 전송.
4. 메시지가 키-값 저장소에 저장됨.
5. 5.a - 사용자 B가 접속 중인 경우 메시지는 B가 접속 중인 채팅 서버(2)로 전송.
    
    5.b - 사용자 B가 미접속 중인 경우 푸시 알림 메시지를 푸시 알림 서버로 보냄
    
6. 채팅 서버 2는 메시지를 사용자 B에게 전송. 사용자 B와 채팅 서버 2 사이에는 웹소켓 연결이 되어있기 때문에 이용해서 실시간 전송가능.

<br/>

- (소규모) 그룹 채팅 메시지 처리 흐름

<img width="411" alt="스크린샷 2024-01-03 오후 11 46 26" src="https://github.com/organization-for-study/study-system-design-interview/assets/126097518/ac122849-fa3e-4035-bf8c-280168f1fd2f">

1. 사용자 A가 그룹채팅방에 메시지를 보내면 메시지는 사용자B, C의 메시지 동기화 큐에 복사됨. 
    1. 위챗이 그룹의 크기를 500명으로 제한하며 이러한 접근법을 사용. 사용자가 많아지면 사용자 큐에 복사하는 방법은 바람직 하지 않을 수 있음.
  
<br/>

**디스코드**

1. **실시간 업데이트 및 채팅:** 디스코드 클라이언트는 웹소켓 연결을 통해 서버와 지속적으로 통신합니다. 이를 통해 실시간으로 업데이트된 정보를 수신하고, 채팅 메시지를 주고받습니다.
2. **1:1 채팅:** 1:1 채팅은 두 사용자 간의 프라이빗 메시지 전송을 의미합니다. 디스코드는 이를 웹소켓을 사용하여 구현하며, 사용자 간의 개별적인 연결을 유지하고 해당 연결을 통해 메시지를 전송합니다.
3. **그룹 채팅 및 서버:** 디스코드는 그룹 채팅과 서버 채널을 제공합니다. 이들은 각각 그룹 채팅방이나 서버 내의 채널을 나타내며, 이들도 마찬가지로 웹소켓을 통해 실시간으로 채팅 및 이벤트 업데이트를 처리합니다.
4. **이벤트 및 상태 업데이트:** 웹소켓은 디스코드에서 다양한 이벤트와 상태 업데이트를 실시간으로 수신할 수 있도록 합니다. 예를 들어, 새로운 메시지 도착, 사용자 상태 변경, 서버 이벤트 등을 실시간으로 처리할 수 있습니다.

<br/>

**디스코드 메시지 흐름** 

1. **웹소켓 연결:** 디스코드 클라이언트가 서버에 연결되면 웹소켓을 사용하여 실시간 통신이 이루어집니다. 이 연결은 사용자의 디바이스와 디스코드 서버 간에 계속 유지됩니다.
2. **1:1 채팅 시작:** 사용자가 상대방과 1:1 채팅을 시작하면, 디스코드 클라이언트는 해당 채팅의 고유한 식별자를 갖는 웹소켓 채널을 생성합니다.
3. **메시지 전송:** 사용자가 메시지를 입력하면, 해당 메시지는 클라이언트에서 디스코드 서버로 웹소켓을 통해 전송됩니다. 이때 메시지는 해당 1:1 채팅의 웹소켓 채널을 통해 전달됩니다.
4. **상대방에게 메시지 전달:** 디스코드 서버는 상대방의 디스코드 클라이언트로 메시지를 전달하기 위해 웹소켓을 사용합니다. 상대방의 클라이언트는 해당 채팅의 웹소켓 채널을 통해 메시지를 수신합니다.
5. **클라이언트에서 메시지 업데이트:** 메시지를 수신한 클라이언트는 채팅 창에 새로운 메시지를 표시합니다. 이 과정에서 채팅창이 자동으로 갱신되어 실시간으로 메시지가 표시됩니다.
6. **읽음 표시 및 알림:** 상대방이 메시지를 읽으면 디스코드는 읽음 표시를 갱신하고, 필요한 경우 알림을 전송하여 사용자에게 알림을 줍니다.

<br/>   

**접속상태 표시**
1. 사용자 로그인
2. 로그아웃
3. 접속장애 - 박동 검사를 통해 해결
4. 상태정보의 전송
   
<br/>
<br/>
