#system-design #study

우리가 흔히 접하는 채팅 시스템들
![](https://i.imgur.com/sYgyCJS.png)

채팅 시스템은 특히 조건이 중요하다.

1. 멀티 채팅이 가능한지.
2. DAU(Daily Active User)의 개략적인 수치
3. 첨부파일의 여부 (종류와 최대 사이즈등)

> 책에서는 결과적으로 네이트온과 유사한 채팅시스템이 필요하다.

- 빠른 응답지연
- 다수의 멀티 채팅도 구현가능
- 사용자의 접속 상태 표시
- 다양한 단말을 지원
- 푸시 알림
- 5천만 DAU를 처리 필요

----

## 프로토콜

기본적인 서버 구조에서는 HTTP기반의 통신을 사용한다.
다만 채팅환경의 경우 기본적인 HTTP/TCP 환경 조건을 고려하기 힘들다.

요건에 따르면 몇천만건의 요청 응답이 발생하는데 그에 따른 IO 오버헤드를 감당할 수 없을 것이기 때문.

이런 요건을 해결하기 위해 나온 걔념들로 Polling / Long Polling / WebSocket 등이 있다.

다만 Polling 계열은 이제는 고려대상이 되기 아쉽기 때문에 간략하게 요약하겠다.

## Polling

- 클라이언트가 주기적으로 새로운 서버에서 새 메시지를 체크하는 형태의 요청 방식
- 주기적으로 **클라이언트**가 확인을 위해 서버에 접근한다.
- 응답이 없을 경우에는 그냥 리소스만 버리는 느낌.

> ![](https://i.imgur.com/5qYZVjo.png)

## Long Polling

![](https://i.imgur.com/0WGb9PJ.png)

- 단순 폴링은 단순히 확인만하지만 롱 폴링은 타임아웃 혹은 메시지 반환 시 까지 연결을 유지한다.
- 말만 봐도 약점이 많아보인다.
    - time out 이 30초인대 무의미하게 연결 유지 중인 커넥션이 있다?

그리고 이런 문제도 있다.

![](https://i.imgur.com/y7tlCdX.png)

클라이언트 한명이 서로 다른 무상태 서버에서 롱폴링시 서로 다른 서버 리전에 접근 시 연동이 안된다.

## WebSocket

- 비동기 처리를 위해 사용되는 기술
- 클라이언트가 HTTP로 요청을 시작하고 특정 핸드셰이크를 거쳐 웹소켓 연결로 변경된다.
- 연결은 비동기적 양방적이다.
    - 서버에서 관리해야한다.
- ack시 http code는 101(프로토콜 전환)

![](https://i.imgur.com/LQmvAtT.png)

![](https://i.imgur.com/sATTDtx.png)


-----

채팅 시스템은 세 부분으로 구분 가능하다.

- stateless(무상태) 서비스
    - 로그인, 회원가입, 사용자 프로필 등 전통적인 요청/응답이 해당된다.
- stateful(상태유지) 서비스
    - 채팅 서비스가 해당된다.
    - 각 클라이언트와 채팅 서버는 독립적인 네트워크 연결을 유지해야한다.
- third-party 연동
    - 푸시 알림이 해당된다.
    - 앱이 실행 중이 아니어도 알림을 받아야한다.

----

![](https://i.imgur.com/wk1Wz5K.png)

- 채팅 서버는 클라이언트 사이에 메세지를 중계하는 역할
- 접속 상태 서버(presence server)는 사용자 접속 여부를 관리
- API 서버는 로그인, 회원가입, 프로파일 변경 등 그 외 나머지 전부를 처리
- 알림 서버는 푸시 알림을 보낸다.
- 키-값 저장소에는 채팅 이력(chat history)을 보관한다. 시스템에 접속한 사용자는 이전 채팅 이력을 전부 보게 될 것이다.

-----

## 저장소

### 채팅 시스템에서 다루는 데이터

1. 사용자의 프로파일, 설정, 친구 목록과 같은 데이터 → 관계형 데이터 베이스
2. 채팅 이력(chat history)
    - 가장 높은 빈도로 사용 되는 것은 최근의 주고 받은 메세지다.
      대부분의 사용자는 오래된 메세지를 들여다보지 않는다.
    - 검색 기능을 이용하거나, 특정 사용자가 언급(mention)된 메시지를 보거나,
      특정 메세지로 점프(jump)하거나 하여 무작위적인 데이터 접근을 하게 되는 일도 있다.
    - 1:1 채팅 앱의 경우 읽기:쓰기 비율은 대략 1:1

채팅 이력의 경우 주로 K:V 저장소를 사용한다.

- 수평적 규모 확장(horizontal scaling)이 쉽다.
- 데이터 접근 지연시간(latency)이 낮다.
- RDB는 롱 테일에 해당하는 부분의 데이터를 잘 처리하지 못하는 경향이 있다. 인덱스가 커지면 무작위 접근을 처리하는 비용이 늘어난다.
- 이미 많은 안정적인 채팅 시스템이 키-값 저장소를 채택 (facebook - HBase, discord - Cassandra)

데이터 모델에 대해서는 생략하겠다.

- 메시지 아이디와 채널 아이디를 키로 가질수 있다는것만 고려하자.
- 여기서 유일키는 우리가 예전에 한 방식으로 고려 가능

----

## 서비스 탐색

![](https://i.imgur.com/7VIZHdi.png)

동작 과정

1. 사용자 A가 시스템에 로그인을 시도 한다.
2. 로드밸런서가 로그인 요청을 API 서버들 가운데 하나로 보낸다.
3. API 서버가 사용자 인증을 처리하고 나면 서비스 탐색 기능이 동작하여 해당 사용자를 서비스할 최적의 채팅 서버를 찾는다.
4. 사용자는 최적의 채팅 서버와 웹소켓 연결을 맺는다.

## 메시지 전달 흐름

![](https://i.imgur.com/Pu6AbwQ.png)
![](https://i.imgur.com/VdlKXNg.png)

## 접속상태 표시

이 부분 좀 단순하게 접근해도 되는데.

로그인시 로그아웃시 websocket 연결 프로토콜을 연결하고 끊는 과정 중에서

타임 스탬프를 호라용해 업데이트 하는 과정을 거친다.

![](https://i.imgur.com/If9x5pX.png)

![](https://i.imgur.com/iNRUdcV.png)

만약 비정상 종료 같은 경우도 많다.

이럴때는 클라이언트의 heartbeat를 통해 주기적인 박동이벤트로 관리할 수 있다.
![](https://i.imgur.com/x9677yE.png)

-----


다른 방식의 채팅 구현 방법은?

위에서 말한 3가지 기술 제외하고도 SSE나 MQ를 활용한 방식으로도

채팅 기능을 충분이 구현할 수 있다.


---

https://developer-youn.tistory.com/113
https://channel.io/ko/blog/real-time-chat-server-3-partitioning