# 8장 - url 단축기 설계

### **1 - 1.**  URL 단축기(URL shortening) 설계 

> URL 단축(URL shortening)은 **월드 와이드 웹 상의 긴 URL을 짧게 만들어 주는 기술**이다. 
유명한 서비스로는 BitryURL이 있다.
> 

**URL 단축기를 설계하는 이유와 장점**
기업들과 개인들이 URL 단축 서비스를 활용하는 이유는 온라인 콘텐츠의 공유 및 홍보 전략에 중요한 역할을 담당합니다.

**URL 단축기를 설계하는 이유와 장점**
기업들과 개인들이 URL 단축 서비스를 활용하는 이유는 온라인 콘텐츠의 공유 및 홍보 전략에 중요한 역할을 담당합니다.

1. **길이 단축**:
    - 가장 명백한 이유는 긴 URL을 짧고 관리하기 쉬운 형태로 줄이기 위함입니다. 
    문자 수 제한이 있는 플랫폼(예: 트위터)에서 유용합니다.
2. **이용 편의성**:
    - 짧은 URL은 사용자가 쉽게 복사하고 붙여넣기 할 수 있으며, 
    텍스트 메시지나 인쇄된 자료에서 사용자가 입력하기에도 더 간편합니다.
3. **추적 가능성**:
    - 단축 URL 서비스는 클릭수, 사용자 위치, 접속한 장치 등의 사용 데이터를 추적하여, 
    웹사이트 운영자가 트래픽을 분석하는 데 도움을 줄 수 있습니다.
4. **브랜딩**:
    - 기업이나 개인은 맞춤형 단축 URL을 사용하여 브랜드 인지도를 높일 수 있습니다. 예를 들어, `brand.link/product` 와 같이 브랜드 이름을 포함한 짧은 URL을 사용할 수 있습니다.
5. **보안 강화**:
    - 단축 서비스는 방문자를 리디렉션하기 전에 원본 URL이 안전한지 검사하여, 악성 사이트로의 접속을 방지합니다.
6. **소셜 미디어 활용 증대**:
    - 짧은 URL은 소셜 미디어 공유에 효과적입니다. 사용자가 긴 URL 대신 짧은 URL을 공유하기 때문에, 메시지가 더 깔끔해 보이고, 메시지의 핵심 내용에 더 집중할 수 있습니다.
7. **마케팅 및 광고 효율성**:
    - 마케팅에서는 다양한 플랫폼과 채널을 통해 URL을  배포한 다음. 각 URL의 성과를 측정해야 하는 경우가 많습니다. 단축 URL서비스에서 쉽게 관리하고 분석할 수 있습니다.
8. **메모리 및 데이터 공간 절약**:
    - 짧은 URL은 서버에서 처리할 때 더 적은 저장 공간을 차지하며, 네트워크를 통한 데이터 전송량도 줄일 수 있습니다.
9. **QR 코드 변환 용이성**:
    - 짧은 URL은 QR 코드로 변환할 때 더 작고 단순한 QR 코드를 생성할 수 있습니다. 단순한 QR코드는 스캔속도가 빨라집니다.
---

**URL 단축의 단점 / 잠재적 문제점**

**URL 단축의 단점 / 잠재적 문제점**

1. **불투명성**:
    - 단축된 URL은 사용자가 클릭하기 전까지 최종 목적지를 알 수 없게 만들어, 사용자가 의도하지 않은 위험한 웹사이트로 리디렉션될 가능성이 있습니다.
2. **악용 가능성**:
    - 사용자는 단축 URL의 불투명성으로, 위장된링크로 불법사이트에 방문할 수 있습니다.
3. **서비스의 종속성**:
    - URL 단축 서비스가 중단될 경우, 모든 단축 URL이 작동하지 않게 됩니다.
4. **추적 및 개인정보 보호**:
    - 단축 URL 서비스들이 클릭 데이터를 추적하므로 사용자의 프라이버시 침해 우려가 있습니다.
5. **성능 지연**:
    - 단축 URL을 통한 추가 리디렉션은 웹 페이지 로딩 시간을 증가시킵니다.
6. **신뢰도 문제**:
    - 많은 이메일 서비스나 메시징 플랫폼은  단축 URL을 필터링하기 때문에, 스팸으로 간주될 수 있습니다.
7. **관리 및 유지보수 그리고 비용**:
    - 단축 URL을 생성하고 관리하는 것은 추가적인 관리 작업을 요구하며, 이는 시간과 자원이 들어가는 일입니다.

이런 장/단점을 갖추고 있어서 꽤나 규모가 큰 기업임에도 단축서비스를 이용하지 않는 서비스도 존재한다.

### 2 **- 1.  문제 이해 및 설계 범위 확정**

> 책에 나온 **전체적인 요구사항은 아래와 같다.**
> 
> 1. 매일 1억개의 단축 URL을 생성할 수 있어야 한다.
> 2. 단축 URL은 짧으면 짧을수록 좋다.
> 3. 생성된 단축 URL은 삭제하거나 갱신할 수 없다.
> 4. 높은 가용성(HA, High Availability)과 규모 확장성(Scalability), 장애 감내(FT, Fault Tolerance)가 요구된다.

*장애 감내 혹은 내결함성이란 ?
시스템을 구성하는 하나 이상의 구성요소에 장애가 발생해도 시스템이 중단없이 계속 작동할 수 있는 성질을 의미한다.

- HA : 
서비스 중단이 허용되는 최소의 시간이 존재한다. 
예를 들어 가용성이 99.99999999999999%인 시스템은 연간 5분의 다운타임을 허용한다.
- FT : 
서비스 중단이 전혀 없이 동작해야한다. 비유하자면 스페어 타이어가 있는 자동차는 HA이다. 타이어는 펑크가 날 수 있지만, 빠른 시간내에 타이어를 교체할 수 있다. 
반면, 엔진이 2개인 쌍발 비행기는 FT이다. 엔진 하나가 고장나도 다른 엔진으로 계속 비행할 수 있다.

---

**계략적 추정**

- 쓰기 연산: 매일 1억 개의 단축 URL 생성
- 초당 쓰기 연산: 1억(100million)/24/3600 = 1160
- 읽기 연산: 읽기 연산과 쓰기 연산 비율은 10:1이다. 그 경우 읽기 연산은 초당 11,600회 발생한다. (1160*10 = 11,600)
- URL 단축 서비스를 10년간 운영한다고 가정하면 1억*365*10 = 3650억 개의 레코드를 보관해야 한다.
- 축약 전 URL의 평균 길이는 100이라고 가정한다.
- 따라서, 10년 동안 필요한 저장 용량은 3650억 * 100바이트 = 36.5 TB이다.

---

**계산방법** 

1. **초당 쓰기 연산 (Write Operations per Second, WOPS)**:
   
  <img width="460" alt="s-0" src="https://github.com/organization-for-study/study-system-design-interview/assets/97773895/de7768a7-5bb7-411f-9aac-c05a80d24185">

- 시스템이 하루 동안 처리해야 할 작업량을 일일 초로 나누어, 평균적인 초당 쓰기 요청량을 산출합니다. 하루는 24시간, 1시간은 3600초, 즉, 하루는 총 86,400초입니다. 
따라서 하루에 1억 개의 URL을 생성해야 한다면, 시스템은 초당 약 1160개의 쓰기 작업을 수행해야 합니다. 시스템이 감당해야 할 최소 쓰기 부하를 나타내며, 피크 타임의 부하는 이보다 클 수 있습니다.

3. **초당 읽기 연산 (Read Operations per Second, ROPS)**:
   
  <img width="456" alt="s-1" src="https://github.com/organization-for-study/study-system-design-interview/assets/97773895/6394688c-3ba8-467a-aa2e-32fc041b76e8">

- 여기서 읽기 연산은 보통 쓰기 연산보다 훨씬 빈번하게 발생합니다. 
단축 URL 서비스의 경우, 사용자는 생성된 단축 URL을 사용해 원본 페이지로 리디렉션을 요청하는 읽기 작업을 더 자주 수행합니다. 
읽기와 쓰기 비율이 10:1이라고 가정할 때, 이는 시스템이 쓰기 작업보다 10배 더 많은 읽기 작업을 처리해야 함을 의미합니다. 따라서 이 공식은 시스템이 초당 처리해야 할 읽기 요청량을 산출합니다.

5. **총 레코드 수 (Total Records over 10 Years)**:
   
   <img width="702" alt="s-2" src="https://github.com/organization-for-study/study-system-design-interview/assets/97773895/3ce0d539-4266-4009-9484-ae0bcbddc042">

- 이 계산은 시스템이 장기간 운영되는 동안 축적될 데이터의 총량을 예측하기 위한 것입니다. 
10년간 매일 1억 개의 단축 URL을 생성한다고 가정하면, 10년 후에 시스템이 처리해야 할 총 레코드 수는 약 3650억 개가 됩니다. 
데이터베이스 설계, 저장소 용량 계획 및 데이터 유지 관리 전략을 결정하는 데 중요한 지표입니다.

7. **필요한 저장 용량 (Total Storage Requirement over 10 Years)**:
   
    <img width="702" alt="s-3" src="https://github.com/organization-for-study/study-system-design-interview/assets/97773895/7c5fcbb0-43d1-4815-b5bd-667f45f44a01">
   
- 시스템이 10년 동안 축적해야 하는 데이터의 양을 계산할 때, 각 URL이 평균적으로 얼마만큼의 공간을 차지하는지 고려해야 합니다.  여기서는 각 URL을 100바이트로 가정하여 계산합니다. 
실제로는 URL이 이보다 길거나 짧을 수 있지만, 평균치를 사용하여 총 저장 용량을 추정합니다. 이를 통해 시스템이 처리해야 할 데이터의 총량과 필요한 저장 공간을 예측할 수 있습니다.

---

### 3 **- 1.  API 엔드포인트**

> URL 단축 서비스를 운영하기 위해서는 **최소한 이 두 가지 엔드포인트**가 필요합니다.
두 개의 엔드포인트는 서로 다른 작업을 수행합니다.
> 
1. **URL 단축 생성 (Shortening a URL)**:
    - **엔드포인트 예시**: 
    `POST` /api/v1/data/shorten
    - **기능**: 
    사용자가 긴 URL을 단축서비스에 전송합니다. 
    해당 요청을 받은 서비스는 짧은 URL을 생성한 뒤 응답으로 반환합니다. 
    `POST` 인 이유는 데이터를 생성하거나 변경하는 '쓰기' 작업에 해당해서 그렇습니다.
2. **URL 리디렉션 (Redirecting to the original URL)**:
    - **엔드포인트 예시**: 
    `GET` /api/v1/shortUrl
    - **기능**: 
    사용자가 짧은 URL을 요청후, 서비스는 원본 긴 URL을 매핑합니다.
    그리고 사용자의 브라우저를 해당 원본 URL로 리디렉션합니다. 
    이 작업은 데이터를 조회하는 '읽기' 작업에 해당합니다.

**예시 :**
사용자가 짧은 URL에 액세스하면, 서비스는 원래의 긴 URL로 사용자를 리디렉션해야 합니다. 
짧은 URL 링크(예: `http://sho.rt/example`)를 클릭하면, URL 단축 서비스는 해당 요청을 받습니다.
단축서비스는 짧은 URL이 원본의 긴 URL(예: `http://www.example.com/very/long/url/path`)에 
해당하는 것을 찾아서, 사용자의 브라우저를 그 긴 URL로 리디렉션합니다.

### 3 **- 2.  왜 두개인가?**

> RESTful API의 설계 원칙 중 하나인 "관심사의 분리"를 따르기 때문입니다.

*관심사의 분리 : 
RESTful API에서 관심사의 분리(Separation of Concerns, SoC)는 각 API 엔드포인트가 한 가지 주요 기능만을 수행하도록 설계하는 것을 의미
> 

따라서, URL 단축 서비스를 운영하기 위해서는 최소한 이 두 가지 엔드포인트가 필요합니다. 
하나는 URL을 단축하는 역할을 하고, 다른 하나는 단축된 URL을 원래의 긴 URL로 리디렉션하는 역할을 합니다.

<img width="584" alt="Untitled (43)" src="https://github.com/organization-for-study/study-system-design-interview/assets/97773895/3b293501-cd52-4b0b-bc82-d33707749937">


### 3 **- 3.  URL 리디렉션**

> URL 리디렉션은 사용자가 특정 웹 주소URL로 브라우저를 통해 접근했을 때, 
해당 주소가 다른 주소로 사용자를 자동으로 안내하는 웹 서버의 동작을 말합니다.
HTTP에서 Redirection에 관한 status, header를 제공합니다.
> 

- **301 Moved Permanently**:
    - 영구적인 URL 리디렉션입니다.
    - 검색 엔진은 이를 인식하여 링크 주스(link juice)를 새로운 URL로 이전합니다.
    - 브라우저는 이 정보를 캐시합니다.
    - 캐시된 데이터로 인해 동일한 주소에 대한 후속 요청을 새 주소로 자동 리디렉션합니다.
    - 캐시 데이터가있으니 서버 부하를 줄이는 데 도움이 될 수 있습니다.
    - 일반적으로 영구적인 주소 변경이 있을 때 사용됩니다.
- **302 Found**:
    - 일시적인 URL 리디렉션을 나타냅니다.
    - 검색 엔진은 URL의 변경을 영구적이지 않다고 간주합니다.
    - 원래 URL에 대한 링크의 가치와 권위를 유지합니다.
    - 브라우저는 캐시를 저장하지 않습니다.
    - 모든 요청은 매번 단축 URL 서버를 통해 원래 URL로 리디렉션됩니다.
    - 트래픽 분석이 중요할 때 유용합니다.
    

### 3 **- 4.  301, 302** 언제사용할까?

> 일반적으로, URL 변경이 일시적이라면 302를, 영구적이라면 301을 사용합니다. 
사용자의 의도와 상황에 맞게 적절한 리디렉션을 사용하는 것이 중요합니다.
> 

**301 Moved Permanently 영구적 리디렉션 언제사용할까?**

- **URL이 영구적으로 변경되었을 때**:
    - 웹페이지가 새 URL로 옮겨진 경우나 사이트 구조가 변경되어 
    기존의 URL을 더 이상 사용하지 않을 때 사용합니다.
- **도메인 이전 시**:
    - 웹사이트가 새 도메인으로 이전하는 경우
    - 기존 도메인에서 새 도메인으로 사용자와 검색 엔진을 안내하기 위해 301 리디렉션을 사용합니다.
- **URL 통합 시**:
    - 여러 URL이 같은 콘텐츠를 가리킬 때, 주로 검색 엔진 최적화(SEO) 목적으로 한 주소로 통합합니다.
- **장점**
    - 검색 엔진은 301 리디렉션을 통해 페이지의 원래 콘텐츠가 새 URL로 옮겨졌음을 인식합니다.
    검색 결과에서 오래된 URL 대신 새 URL을 표시합니다.
    - 링크 주스(link juice) 또는 페이지 권위가 새 URL로 이전됩니다.
- **주의할 점**
    - 사용자의 브라우저는 301 리디렉션을 캐시하므로, URL 변경을 되돌리기 어렵습니다.

**302 Found 임시적 리디렉션 제사용할까?**

- **임시적인 콘텐츠 변경 시**:
    - 원래 페이지를 업데이트 중일 때, 임시 페이지로 사용자를 안내할 필요가 있을 때 사용합니다.
- **A/B 테스팅 시**:
    - 사용자의 반응을 테스트하기 위해 동일한 URL에 대해 다른 버전의 페이지를 보여줄 때 사용합니다.
- **프로모션이나 이벤트 시**:
    - 특정 기간 동안만 진행되는 프로모션 페이지로 리디렉션할 때 사용합니다.
- **장점**
    - 임시적인 변경이므로, 원래 URL의 SEO 가치를 유지합니다.
    - 브라우저는 302 리디렉션을 캐시하지 않기 때문에, 변경을 쉽게 되돌릴 수 있습니다.
- **주의할 점**
    - 302 리디렉션이 장기간 사용될 경우, 검색 엔진이 영구적인 리디렉션으로 오해할 수 있으므로 주의가 필요합니다.

**SEO 측면에서보면 301이 302보다 더 좋습니다.**

- 301상태는 리디렉션을 통해 원본 검색 엔진 순위, 링크주스, 메타데이터를 새로운 URL로 전송합니다.
- 기존 페이지의 SEO가치를 새 페이지로 효과적으로 이전합니다.
- 302같은경우 원본 URL이 일시적으로 다른 위치로 이동했다는 의미기때문에 기존 URL의 가치를 새 URL로 이전하지않습니다.
- 302 리디렉션은 이벤트나 프로모션 A/B테스팅 등 특정상황에서는 유용하지만, 장기적인 SEO가치에는 기여하지 않습니다.

### 3 **- 5. URL 단축과 해시값 - 해시함수**

> URL을 단축시킬때 해시값을 사용한다.
www.tinyurl.com/[hashValue] 에서  [hashValue]는 원본 URL을 대표하는 고유한 해시값입니다.
> 

<img width="197" alt="Untitled (44)" src="https://github.com/organization-for-study/study-system-design-interview/assets/97773895/c37d4762-40c3-42c8-a09b-8c367738dc07">

- **해시값 :**
    - 해시값은 원본 데이터를 대표하는 고정 길이의 값입니다.
    - 해시 함수를 통해 계산됩니다.
    - 어떤 길이의 데이터든지 간에 고정된 크기의 해시값으로 매핑하는 역할을합니다.
    - 주로 데이터 관리 및 검색 알고리즘에서 사용됩니다.
        - **데이터 저장**: 
        해시 테이블 같은 자료 구조에서는 해시값을 사용하여 데이터를 빠르게 저장하고 검색할 수 있습니다.
        - **보안**: 
        암호학에서 해시 함수는 패스워드 저장, 메시지의 무결성 검사, 디지털 서명 등에 사용됩니다.
        - **데이터 무결성**: 
        파일이나 메시지가 전송 과정에서 변경되지 않았는지 확인하기 위해 사용됩니다.

---

- **URL 단축 서비스에서 해시 함수의 역할과 중요한 특성을 갖는가 :**
    - **고유성**:
        - 각 원본 URL이 서로 다른 해시값을 가져야 합니다.
        - 즉, 각 URL이 고유한 단축 URL을 가질 수 있도록 합니다.
        - 해시 함수는 충돌 가능성을 최소화하는 방식으로 설계되어야 합니다.
    - **역추적 가능성**:
        - URL 단축 서비스에서는 해시값을 이용해 원본 URL을 역추적할 수 있어야 합니다.
        - 이를 위해 서비스 제공자는 해시값과 원본 URL의 매핑을 데이터베이스에 저장합니다.
        - 사용자가 단축 URL을 사용할 때 해당 원본 URL로 리디렉션될 수 있도록 합니다.

### 4 **- 1. 상세설계**

> **초기 고려 사항:**
> 
> 
>   **목적**: 
> 긴 URL을 짧고 관리하기 쉬운 형태로 변환하여 공유 및 사용 용이성을 증대시킵니다.
> 
> **도전 과제**: 
> 각 URL에 대해 영구적이고 충돌을 방지할 수 있는 고유 식별자를 생성합니다.
> 

### 2. 데이터 모델:

- **데이터베이스 구조**: `<단축 URL, 원래 URL>`의 매핑을 저장하기 위해 관계형 데이터베이스를 사용합니다.
- **필드 구성**: id, shortURL, longURL의 세 개 칼럼을 포함합니다.

### 3. 해시 함수와 변환 전략:

- **해시 함수**: 원래 URL을 단축 URL로 변환하는 데 사용됩니다.
- **해시 값 길이**: hashValue는 [0-9, a-z, A-Z]의 문자로 구성되며, `62^n >= 3650억`을 만족하는 n의 최솟값을 찾아야 합니다 (n = 7일 시 3.5조 개의 URL 생성 가능).

---

### 4. 해시 함수 사용:

- 긴 URL을 7글자의 문자열로 줄이기 위해 CRC32, MD5, SHA-1 같은 잘 알려진 해시 함수를 사용합니다.
- 이러한 해시 함수는 원본 URL을 대표하는 고유한 해시값을 생성합니다.

1. **해시값 길이 축소**:
- 생성된 해시값은 일반적으로 7글자보다 길기 때문에, 해시값의 처음 7글자만 사용하는 방법을 고려합니다.
- 이 방법을 사용하면 해시 충돌의 확률이 높아집니다. 해시 충돌은 서로 다른 URL이 동일한 해시값을 가지는 경우를 의미합니다.
1. **해시 충돌 해소**:
    - 충돌이 발생하면, 충돌이 해소될 때까지 사전에 정한 문자열을 해시값에 덧붙여 충돌을 해소합니다.
    - 이 과정은 데이터베이스를 여러 번 질의해야 하므로 오버헤드가 발생할 수 있습니다.

**블룸 필터 사용**:

- 블룸 필터는 확률론에 기초한 공간 효율적인 방법으로, 집합에 특정 원소가 있는지 빠르게 검사할 수 있습니다.
- 데이터베이스 대신 블룸 필터를 사용하면 성능을 향상시킬 수 있습니다.

### 5. Base-62 변환:

1. **Base-62 변환의 사용**:
    - URL 단축키를 구현할 때 진법 변환 (Base Conversion)은 흔히 사용되는 방법입니다.
    - Base-62 변환은 알파벳 대소문자 (26 + 26)와 숫자 (10)를 합쳐 총 62개의 가능한 문자를 사용합니다.
2. **변환의 목적**:
    - 이 방법은 수의 표현 방식이 다른 두 시스템 사이에서 같은 수치를 공유할 때 유용합니다.
    - Base-62는 해시값을 짧고 사용자 친화적인 형태로 변환하는 데 적합합니다.
3. **변환 예시**:
    - 예를 들어, 10진수 11157을 Base-62로 변환하면 "2TX"가 됩니다.
    - 이러한 변환은 해시값을 짧은 URL 형태로 효과적으로 변환하는 데 사용됩니다.
4. **해시와 비교:**
    
![IMG_4873](https://github.com/organization-for-study/study-system-design-interview/assets/97773895/669bb12e-44cc-4221-a602-5d4cae46a255)

    

### 5. 시스템의 흐름:

- **처리 과정**: 긴 URL 입력 → DB 확인 → 기존 URL 있으면 단축 URL 반환 → 없으면 유일한 ID 생성 → 62진법 변환 적용 → DB에 저장 → 단축 URL 반환.

### 6. URL 리디렉션과 로드밸런싱:

- **캐시 활용**: 읽기가 더 많은 시스템이므로 캐시에 <단축 URL, 원래 URL> 쌍을 저장합니다.
- **로드밸런서**: 사용자가 단축 URL을 클릭하면, 로드밸런서가 웹 서버에 요청을 전달하고, 캐시에 없는 경우 데이터베이스에서 조회합니다.

### 7. 시스템 확장성:

- **웹 서버 확장**: 웹 계층은 무상태 계층으로, 웹 서버를 자유롭게 증설하거나 삭제할 수 있습니다.
- **데이터베이스 확장**: 데이터베이스 다중화, 샤딩 등을 통해 규모를 확장합니다.

### 8. 데이터 분석과 모니터링:

- **분석 솔루션**: 데이터 분석 솔루션을 통합하여 링크 클릭 통계를 추적합니다.
- **모니터링 및 로깅**: 시스템의 안정성과 성능을 모니터링하고 문제를 실시간으로 감지합니다.
